# Evenia

<a alt="Nx logo" href="https://nx.dev" target="_blank" rel="noreferrer"><img src="https://raw.githubusercontent.com/nrwl/nx/master/images/nx-logo.png" width="45"></a>

✨ **This workspace has been generated by [Nx, a Smart, fast and extensible build system.](https://nx.dev)** ✨

## Deployed version
There is a deployed version of this app. The back and front ends are separate, with the front hosted on Vercel and the back hosted on Railway.

- [BackEnd](https://evenia-production.up.railway.app/) - Includes a [GraphQL Playground](https://evenia-production.up.railway.app/graphiql) for testing
- [FrontEnd](https://evenia-one.vercel.app/)

## Local Usage
The package.json in the main folder contains several scripts that might prove useful to run the app:

- `serve:all`: This command is used to start both the api and web servers concurrently. If either process fails, it kills the other one. This is convenient for development where you might be working on both the API and the frontend.

- `start:api`: This command is used to start the API server.

- `start:web`: This command is used to start the web server.

- `test`: This command runs the test suites in the application using nx.

- `dockers:dev`: This command starts the docker containers defined in the `dev.docker-compose.yaml` file, which defines the MySQL instance to run locally.

- `db:migrate:dev`: This command runs database migrations on the development database using Prisma.

- `db:studio`: This command opens Prisma Studio, which is a database GUI for Prisma.

- `gen:gql-web`: This command generates TypeScript typings for the GraphQL schema defined in the `codegen.yml` file.

- `cd:api`: This command is used as the build command on the Railway deployment.

- `cd:web`: This command is used as the build command on the Vercel deployment

- `cd:db-push`: This command is used in the backend deployment to push the database changes. 

## Notorious design decisions
- I implemented the Bonus 1 (separate backend) from the get-go, as I felt it was both important, and would be "easier" to start development with that in mind, rather than migrate the backend from NextJS + Vercel serverless. Also, from my conversation with Timur, I got the feeling doing this could be representative of the actual work that Trustblock needs to be done.

- I used NX to generate the monorepo; I haven´t worked before with it, but had been tinkering a bit with it, and like the results so far.

- For this separate backend, I used NestJS, which is both what I´m more familiar with and the techstack to be used in Trustblock. 

- I also added an implementation of GraphQL, which is both tech I like and I´m familiar with. While not necessary, I think the way it´s setup would improve development times when extending the project. 

- When integrating the backend with NextAuth, I used jwt as the method of authentication. JWTs are generated on the frontend through NextAuth (through a serverside API), and validated on the backend through Passport. Both the backend and frontend use the same secret to encrypt/decrypt.

- On the frontend, I switched scss for ChakraUI. This was a time based decision, as for the past few months I´ve been mostly on backend, and have never used scss. So, I went with what I was more familiar with in the interest of saving time.

- I followed the style guide on Figma where possible, but the frontend is not a perfect reflection of it, due to time constraints. Also, some things are just placeholders, for example the image uploader for the events (as the backend events don´t have a definition for images).

- The images for the events are just random images generated with Unsplash. For next steps, a system to upload such images (to for example S3) would have to be implemented.

- Both Jest and Cypress are setup in the project for unit and e2e testing respectively. However, I haven´t been able to find the time to add tests yet.

## Left to do
- Unit tests would be the main thing to work on, as well as e2e.
- Authentication bonuses, like verification by email and crypto wallet verification.
- Add more responsiveness to the front end, for example, expanding the behaviour of Toast elements for performing CRUD on events.
